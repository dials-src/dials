# DIALS_ENABLE_COMMAND_LINE_COMPLETION


from __future__ import annotations

import concurrent.futures
import copy
import logging
import sys

import iotbx.phil
from dxtbx.model.experiment_list import Experiment, ExperimentList
from libtbx import Auto

from dials.algorithms.indexing import DialsIndexError, indexer
from dials.array_family import flex
from dials.util import log, show_mail_handle_errors
from dials.util.multi_dataset_handling import generate_experiment_identifiers
from dials.util.options import ArgumentParser, reflections_and_experiments_from_files
from dials.util.slice import slice_reflections
from dials.util.version import dials_version

logger = logging.getLogger("dials.command_line.index")


help_message = """

This program attempts to perform autoindexing on strong spots output by the
program dials.find_spots. The program is called with a "imported.expt" file
(as generated by dials.import) and a "strong.refl" file (as generated by
dials.find_spots). If one or more lattices are identified given the input
list of strong spots, then the crystal orientation and experimental geometry
are refined to minimise the differences between the observed and predicted
spot centroids. The program will output an "indexed.expt" file which
is similar to the input "imported.expt" file, but with the addition of the
crystal model(s), and an "indexed.refl" file which is similar to the input
"strong.refl" file, but with the addition of miller indices and predicted
spot centroids.

dials.index provides both one-dimensional and three-dimensional fast Fourier
transform (FFT) based methods. These can be chosen by setting the parameters
indexing.method=fft1d or indexing.method=fft3d. By default the program searches
for a primitive lattice, and then proceeds with refinement in space group P1.
If the unit_cell and space_group parameters are set, then the program will
only accept solutions which are consistent with these parameters. Space group
constraints will be enforced in refinement as appropriate.

Examples::

  dials.index imported.expt strong.refl

  dials.index imported.expt strong.refl unit_cell=37,79,79,90,90,90 space_group=P43212

  dials.index imported.expt strong.refl indexing.method=fft1d
"""


phil_scope = iotbx.phil.parse(
    """\
include scope dials.algorithms.indexing.indexer.phil_scope

indexing {

    include scope dials.algorithms.indexing.lattice_search.basis_vector_search_phil_scope

    image_range = None
      .help = "Range in images to slice a sequence. The number of arguments"
              "must be a factor of two. Each pair of arguments gives a range"
              "that follows C conventions (e.g. j0 <= j < j1) when slicing the"
              "reflections by observed centroid."
      .type = ints(size=2)
      .multiple = True

    joint_indexing = Auto
      .type = bool

}

include scope dials.algorithms.refinement.refiner.phil_scope

output {
  experiments = indexed.expt
    .type = path
  reflections = indexed.refl
    .type = path
  retain_unindexed_experiments = True
    .type = bool
    .help = "If True, the input experiment models are extended with new crystal"
            "models, thus the output contains a crystal-less experiment for each"
            "imageset that matches the unindexed reflections. Setting this option"
            "to False recovers the old behaviour of versions DIALS 3.17 and earlier."
  log = dials.index.log
    .type = str
}
""",
    process_includes=True,
)

# override default refinement parameters
phil_overrides = phil_scope.fetch(
    source=iotbx.phil.parse(
        """\
refinement {
    reflections {
        reflections_per_degree=100
    }
}
"""
    )
)

working_phil = phil_scope.fetch(sources=[phil_overrides])


def _index_single_imageset(experiments, reflections, params, log_text=None):
    if log_text:
        logger.info(log_text)

    unindexed = [i for i in experiments if not i.crystal]
    # handle legacy cases where no unindexed experiments:
    if not unindexed:  # i.e. all have crystals
        unindexed = [
            Experiment(
                crystal=None,
                beam=experiments[0].beam,
                detector=experiments[0].detector,
                goniometer=experiments[0].goniometer,
                scan=experiments[0].scan,
                imageset=experiments[0].imageset,
                profile=experiments[0].profile,
                scaling_model=experiments[0].scaling_model,
            )
        ]
        generate_experiment_identifiers(unindexed)
        input_expts = experiments
        known_crystal_models = [expt.crystal for expt in experiments]
    else:
        if any(experiments.crystals()):
            input_expts = ExperimentList([i for i in experiments if i.crystal])

            known_crystal_models = [expt.crystal for expt in input_expts]
        else:
            input_expts = experiments
            known_crystal_models = None

    idxr = indexer.Indexer.from_parameters(
        reflections,
        input_expts,
        known_crystal_models=known_crystal_models,
        params=params,
    )
    idxr.index()
    if not params.output.retain_unindexed_experiments:
        idx_refl = copy.deepcopy(idxr.refined_reflections)
        idx_refl.extend(idxr.unindexed_reflections)
        return idxr.refined_experiments, idx_refl

    # update the identifiers so that the unindexed has id 0, and the rest 1,2,3.. etc
    idxr.unindexed_reflections["id"] = flex.int(idxr.unindexed_reflections.size(), 0)
    idxr.unindexed_reflections.experiment_identifiers()[0] = unindexed[0].identifier
    if idxr.unindexed_reflections.size():
        idxr.unindexed_reflections.clean_experiment_identifiers_map()

    idx_refl = idxr.refined_reflections
    for id_ in sorted(set(idx_refl["id"]), reverse=True):
        identifier = idx_refl.experiment_identifiers()[id_]
        del idx_refl.experiment_identifiers()[id_]
        idx_refl.experiment_identifiers()[id_ + 1] = identifier
    idx_refl["id"] += 1

    # the refiner copies the input beam, detector and gonio, we want to share these
    unindexed[0].detector = idxr.refined_experiments[0].detector
    unindexed[0].beam = idxr.refined_experiments[0].beam
    if idxr.refined_experiments[
        0
    ].goniometer:  # might be using the stills indexer which deletes the gonio
        unindexed[0].goniometer = idxr.refined_experiments[0].goniometer

    # Now join everything together for output
    indexed_experiments = ExperimentList(unindexed)
    indexed_experiments.extend(idxr.refined_experiments)
    idx_refl.extend(idxr.unindexed_reflections)
    idx_refl.assert_experiment_identifiers_are_consistent(indexed_experiments)

    return indexed_experiments, idx_refl


def _index_joint_indexing(experiments, reflections, params):

    # first make an unindexed experiments for each imageset.
    unindexed = [i for i in experiments if not i.crystal]
    original_imagesets = experiments.imagesets()
    # handle legacy cases where no unindexed experiments:
    if not unindexed:  # i.e. all have crystals
        unindexed = []
        for iset in experiments.imagesets():
            i_expt = experiments.where(imageset=iset)
            expt_to_copy = experiments[i_expt[0]]
            unindexed.append(
                Experiment(
                    crystal=None,
                    beam=expt_to_copy.beam,
                    detector=expt_to_copy.detector,
                    goniometer=expt_to_copy.goniometer,
                    scan=expt_to_copy.scan,
                    imageset=expt_to_copy.imageset,
                    profile=expt_to_copy.profile,
                    scaling_model=expt_to_copy.scaling_model,
                )
            )
        generate_experiment_identifiers(unindexed)
        input_expts = experiments
        known_crystal_models = [expt.crystal for expt in experiments]
    else:
        if any(experiments.crystals()):
            input_expts = ExperimentList([i for i in experiments if i.crystal])
            # note not just experiments.crystals(), as models may be shared.
            known_crystal_models = [expt.crystal for expt in input_expts]
        else:
            input_expts = experiments
            known_crystal_models = None

    for id_ in sorted(set(reflections["id"]).difference({-1}), reverse=True):
        del reflections.experiment_identifiers()[id_]
    reflections["original_id"] = copy.deepcopy(reflections["imageset_id"])
    reflections["id"] = copy.deepcopy(reflections["imageset_id"])
    idxr = indexer.Indexer.from_parameters(
        reflections,
        input_expts,
        known_crystal_models=known_crystal_models,
        params=params,
    )
    idxr.index()
    if not params.output.retain_unindexed_experiments:
        idx_refl = copy.deepcopy(idxr.refined_reflections)
        idx_refl.extend(idxr.unindexed_reflections)
        return idxr.refined_experiments, idx_refl

    # now want to split up so that the output is in imageset order
    indexed_experiments = ExperimentList([])
    indexed_reflections = flex.reflection_table()
    n_id = 0
    for i, iset in enumerate(original_imagesets):
        # first sort out the unindexed
        identifier = unindexed[i].identifier
        sel = idxr.unindexed_reflections["original_id"] == i
        unindexed_refl = idxr.unindexed_reflections.select(sel)
        unindexed_refl["id"] = flex.int(unindexed_refl.size(), n_id)
        del unindexed_refl["original_id"]
        unindexed_refl.clean_experiment_identifiers_map()
        unindexed_refl.experiment_identifiers()[n_id] = identifier
        n_id += 1
        indexed_reflections.extend(unindexed_refl)
        indexed_experiments.append(unindexed[i])
        # now get the indexed
        i_expts = idxr.refined_experiments.where(imageset=iset)
        identifiers = [idxr.refined_experiments[i].identifier for i in i_expts]
        n_indexed_this = len(identifiers)
        refls = idxr.refined_reflections.select_on_experiment_identifiers(identifiers)
        refls.reset_ids()  # number from 0
        # now reset the ids in the refls
        for id_ in sorted(set(refls["id"]), reverse=True):
            identifier = refls.experiment_identifiers()[id_]
            del refls.experiment_identifiers()[id_]
            refls.experiment_identifiers()[id_ + n_id] = identifier
        refls["id"] += n_id
        n_id += n_indexed_this
        del refls["original_id"]
        indexed_reflections.extend(refls)
        # the refiner copies the input beam, detector and gonio, we want to share these
        indexed_experiments[-1].detector = idxr.refined_experiments[i_expts[0]].detector
        indexed_experiments[-1].beam = idxr.refined_experiments[i_expts[0]].beam
        if idxr.refined_experiments[
            i_expts[0]
        ].goniometer:  # might be using the stills indexer which deletes the gonio
            indexed_experiments[-1].goniometer = idxr.refined_experiments[
                i_expts[0]
            ].goniometer
        for j in i_expts:
            indexed_experiments.append(idxr.refined_experiments[j])
    indexed_reflections.assert_experiment_identifiers_are_consistent(
        indexed_experiments
    )

    return indexed_experiments, indexed_reflections


def _index_experiments(
    experiments,
    reflections,
    params,
    known_crystal_models=None,
    log_text=None,
):
    if log_text:
        logger.info(log_text)
    idxr = indexer.Indexer.from_parameters(
        reflections,
        experiments,
        known_crystal_models=known_crystal_models,
        params=params,
    )
    idxr.index()
    idx_refl = copy.deepcopy(idxr.refined_reflections)
    idx_refl.extend(idxr.unindexed_reflections)
    return idxr.refined_experiments, idx_refl


def index(experiments, reflections, params):
    """
    Index the input experiments and reflections.

    Args:
        experiments: The experiments to index
        reflections (list): A list of reflection tables containing strong spots
        params: An instance of the indexing phil scope

    Returns:
        (tuple): tuple containing:
            experiments: The indexed experiment list
            reflections (dials.array_family.flex.reflection_table):
                The indexed reflections

    Raises:
        ValueError: `reflections` is an empty list or `experiments` contains a
                    combination of sequence and stills data.
        dials.algorithms.indexing.DialsIndexError: Indexing failed.
    """

    if len(reflections) == 0:
        raise ValueError("No reflection lists found in input")
    elif len(reflections) == 1:
        if "imageset_id" not in reflections[0]:
            reflections[0]["imageset_id"] = reflections[0]["id"]
    elif len(reflections) > 1:
        assert len(reflections) == len(experiments)
        for i in range(len(reflections)):
            reflections[i]["imageset_id"] = flex.int(len(reflections[i]), i)
            if i > 0:
                reflections[0].extend(reflections[i])
    reflections = reflections[0]

    if params.indexing.image_range:
        reflections = slice_reflections(reflections, params.indexing.image_range)

    if params.indexing.joint_indexing is Auto:
        if all(e.is_still() for e in experiments):
            params.indexing.joint_indexing = False
            logger.info("joint_indexing=False has been set for stills experiments")
        elif all(not e.is_still() for e in experiments):
            params.indexing.joint_indexing = True
            logger.info("joint_indexing=True has been set for scans experiments")
        else:
            raise ValueError(
                "Unable to set joint_indexing automatically for a mixture of stills and scans experiments"
            )

    if len(experiments.imagesets()) == 1:
        indexed_experiments, indexed_reflections = _index_single_imageset(
            experiments,
            reflections,
            copy.deepcopy(params),
        )
    elif params.indexing.joint_indexing:
        indexed_experiments, indexed_reflections = _index_joint_indexing(
            experiments,
            reflections,
            copy.deepcopy(params),
        )
    else:
        indexed_experiments = ExperimentList()

        with concurrent.futures.ProcessPoolExecutor(
            max_workers=params.indexing.nproc
        ) as pool:
            futures = {}
            # we might have multiple lattices per imageset, so need to select on imageset rather than experiment
            for iset_id, imgset in enumerate(experiments.imagesets()):
                refl = reflections.select(reflections["imageset_id"] == iset_id)
                i_expts = experiments.where(imageset=imgset)
                elist = ExperimentList([experiments[i] for i in i_expts])
                assert len(elist.imagesets()) == 1
                refl["imageset_id"] = flex.int(
                    len(refl), 0
                )  # _index_experiments functions requires ids numbered from 0
                futures[
                    pool.submit(
                        _index_single_imageset,
                        elist,
                        refl,
                        copy.deepcopy(params),
                        log_text=f"Indexing imageset id {iset_id} ({iset_id + 1}/{len(experiments.imagesets())})",
                    )
                ] = iset_id

            tables_list = []
            for future in concurrent.futures.as_completed(futures):
                try:
                    iset_id = futures[future]
                    idx_expts, idx_refl = future.result()
                    # the result will contain an unindexed experiment followed by up to N=max_lattices experiments with crystals
                except Exception as e:
                    print(e)
                else:
                    if idx_expts is None:
                        continue
                    # reset the imageset id to the original
                    idx_refl["imageset_id"] = flex.int(idx_refl.size(), iset_id)
                    tables_list.append(idx_refl)
                    indexed_experiments.extend(idx_expts)
        indexed_reflections = flex.reflection_table.concat(tables_list)
    return indexed_experiments, indexed_reflections


@show_mail_handle_errors()
def run(args=None, phil=working_phil):
    usage = "dials.index [options] models.expt strong.refl"

    parser = ArgumentParser(
        usage=usage,
        phil=phil,
        read_reflections=True,
        read_experiments=True,
        check_format=False,
        epilog=help_message,
    )

    params, options = parser.parse_args(args=args, show_diff_phil=False)

    # Configure the logging
    log.config(verbosity=options.verbose, logfile=params.output.log)
    logger.info(dials_version())

    # Log the diff phil
    diff_phil = parser.diff_phil.as_str()
    if diff_phil != "":
        logger.info("The following parameters have been modified:\n")
        logger.info(diff_phil)

    reflections, experiments = reflections_and_experiments_from_files(
        params.input.reflections, params.input.experiments
    )

    if len(experiments) == 0:
        parser.print_help()
        return

    try:
        indexed_experiments, indexed_reflections = index(
            experiments, reflections, params
        )
    except (DialsIndexError, ValueError) as e:
        sys.exit(str(e))

    # Save experiments
    logger.info("Saving refined experiments to %s", params.output.experiments)
    assert indexed_experiments.is_consistent()
    indexed_experiments.as_file(params.output.experiments)

    # Save reflections
    logger.info("Saving refined reflections to %s", params.output.reflections)
    indexed_reflections.as_file(filename=params.output.reflections)


if __name__ == "__main__":
    run()
